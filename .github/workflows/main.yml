name: Terraform

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/destroy.yml' 
  
env:
 # Credentials for deployment to AWS
 AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
 AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
 AWS_REGION: us-east-1

jobs:
  push_to_docker_hub:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Log in to Docker Hub
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build Docker image
        run: docker build -t challenge .
      - name: Tag the image
        run: docker tag challenge:latest ${{ secrets.DOCKER_USERNAME }}/challenge:latest    

      - name: Push Docker image to Docker Hub
        run: docker push ${{ secrets.DOCKER_USERNAME }}/challenge:latest
  

  terraform:
   needs: push_to_docker_hub
   runs-on: ubuntu-latest


   steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
          
      - name: Terraform Init
        run: terraform init -backend-config="bucket=${{ secrets.BUCKET_TF_STATE }}" -backend-config="key=terraform.tfstate" -backend-config="region=us-east-1"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'  
        run: terraform apply -auto-approve tfplan

      # Step 8: Capture Terraform Outputs and write to file
      - name: Fetch Terraform Outputs and write to file
        run: |
          echo "Fetching Terraform outputs..."
          
          # Fetching the IPs directly (No JSON Parsing)
          MASTER_IPS=$(terraform output -raw master_node_ip || echo "")
          WORKER_IPS=$(terraform output -raw worker_node_ips || echo "")
          MASTER_PRIVATE_IP=$(terraform output -raw master_private_ip || echo "")
          WORKER_PRIVATE_IP=$(terraform output -raw worker_private_ips || echo "")

          # Check if any of the outputs are missing or empty
          if [ -z "$MASTER_IPS" ] || [ -z "$WORKER_IPS" ] || [ -z "$MASTER_PRIVATE_IP" ] || [ -z "$WORKER_PRIVATE_IP" ] ; then
            echo "Error: One or more Terraform outputs are missing or empty."
            exit 1
          fi

          # Write the IPs to a file (this file will be used by the ansible job)
          echo "MASTER_IPS=$MASTER_IPS" > terraform_output.txt
          echo "WORKER_IPS=$WORKER_IPS" >> terraform_output.txt
          echo "MASTER_PRIVATE_IP=$MASTER_PRIVATE_IP" >> terraform_output.txt
          echo "WORKER_PRIVATE_IP=$WORKER_PRIVATE_IP" >> terraform_output.txt

          # Print the IPs to the log
          echo "Master IPs: $MASTER_IPS"
          echo "Worker IPs: $WORKER_IPS"
          echo "Private_Master_IP: $MASTER_PRIVATE_IP"
          echo "Private_Worker_IP: $WORKER_PRIVATE_IP"
          

      # Upload the file as an artifact so it can be accessed in the next job
      - name: Upload Terraform Output File
        uses: actions/upload-artifact@v4
        with:
          name: terraform_output_file
          path: terraform_output.txt

  
  setup_k3s:
    needs: terraform
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout code
      - name: Checkout code
        uses: actions/checkout@v3


      # Step 3: Download the Terraform output file
      - name: Download Terraform Output File
        uses: actions/download-artifact@v4
        with:
          name: terraform_output_file

      # Step 4: Read the IPs from the file
      - name: Read IPs from the file
        run: |
          # Read IPs from the file using `cat` and `cut` to extract values
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)
          MASTER_PRIVATE_IP=$(cat terraform_output.txt | grep "MASTER_PRIVATE_IP" | cut -d'=' -f2)
          WORKER_PRIVATE_IP=$(cat terraform_output.txt | grep "WORKER_PRIVATE_IP" | cut -d'=' -f2)
          
          
          

          # Ensure the variables are set correctly
          echo "MASTER_IPS: $MASTER_IPS"
          echo "WORKER_IPS: $WORKER_IPS"
          echo "MASTER_PRIVATE_IP: $MASTER_PRIVATE_IP"
          echo "WORKER_PRIVATE_IP: $WORKER_PRIVATE_IP"


    
      - name: Configure SSH Access
        run: |
          mkdir -p ~/.ssh  # Ensure the .ssh directory exists
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa  

      - name: Set up SSH Keys on Ansible Control Node
        run: |
          # Ensure the .ssh directory exists
          mkdir -p ~/.ssh
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)

      - name: Install K3s on master node
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          MASTER_PRIVATE_IP=$(cat terraform_output.txt | grep "MASTER_PRIVATE_IP" | cut -d'=' -f2)
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@${MASTER_IPS} << 'EOF'
            curl -sfL https://get.k3s.io | sh -
            sudo chmod 644 /etc/rancher/k3s/k3s.yaml
            echo "K3s installed on master node"
            echo "export KUBECONFIG=/etc/rancher/k3s/k3s.yaml" >> ~/.bashrc
            source ~/.bashrc
    
          EOF

          
      - name: Install K3s on worker nodes
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)
          MASTER_PRIVATE_IP=$(cat terraform_output.txt | grep "MASTER_PRIVATE_IP" | cut -d'=' -f2)
          WORKER_PRIVATE_IP=$(cat terraform_output.txt | grep "WORKER_PRIVATE_IP" | cut -d'=' -f2)
          K3S_TOKEN=$(ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$MASTER_IPS "sudo /usr/local/bin/k3s token create")
          echo "K3S_TOKEN=$K3S_TOKEN"
          IFS=',' read -ra ADDR <<< "${WORKER_IPS}"
          for worker_ip in "${ADDR[@]}"; do
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$worker_ip << EOF
              curl -sfL https://get.k3s.io | K3S_URL=https://${MASTER_PRIVATE_IP}:6443 K3S_TOKEN=$K3S_TOKEN sh -
          EOF
          done

      - name: Copy k3s.yaml from Master Node to GitHub Runner
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)
          MASTER_PRIVATE_IP=$(cat terraform_output.txt | grep "MASTER_PRIVATE_IP" | cut -d'=' -f2)
          WORKER_PRIVATE_IP=$(cat terraform_output.txt | grep "WORKER_PRIVATE_IP" | cut -d'=' -f2)
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@${MASTER_IPS}:/etc/rancher/k3s/k3s.yaml ./k3s.yaml
          sed -i "s|127.0.0.1|${MASTER_PRIVATE_IP}|" k3s.yaml

      - name: Copy k3s.yaml from GitHub Runner to Worker Nodes
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)

          IFS=',' read -ra ADDR <<< "${WORKER_IPS}"
          for worker_ip in "${ADDR[@]}"; do
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$worker_ip "mkdir -p /home/ubuntu/.kube"
            scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ./k3s.yaml ubuntu@$worker_ip:/home/ubuntu/.kube/k3s.yaml
          done

      - name: Verify k3s.yaml exists on Worker Nodes
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)
          MASTER_PRIVATE_IP=$(cat terraform_output.txt | grep "MASTER_PRIVATE_IP" | cut -d'=' -f2)
          WORKER_PRIVATE_IP=$(cat terraform_output.txt | grep "WORKER_PRIVATE_IP" | cut -d'=' -f2)
          IFS=',' read -ra ADDR <<< "${WORKER_IPS}"
          for worker_ip in "${ADDR[@]}"; do
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$worker_ip << EOF
              
              if [ -f /home/ubuntu/.kube/k3s.yaml ]; then
                echo "k3s.yaml exists on $worker_ip"
                sudo chmod 644 /home/ubuntu/.kube/k3s.yaml
              else
                echo "ERROR: k3s.yaml NOT found on $worker_ip"
                exit 1
              fi
          EOF
          done

      - name: Verify Worker Node Joins Cluster
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)
          MASTER_PRIVATE_IP=$(cat terraform_output.txt | grep "MASTER_PRIVATE_IP" | cut -d'=' -f2)
          WORKER_PRIVATE_IP=$(cat terraform_output.txt | grep "WORKER_PRIVATE_IP" | cut -d'=' -f2)
          IFS=',' read -ra ADDR <<< "${WORKER_IPS}"
          for worker_ip in "${ADDR[@]}"; do
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$worker_ip << EOF
              KUBECONFIG=/home/ubuntu/.kube/k3s.yaml kubectl get nodes
          EOF
          done

      - name: Verify K3s Cluster Status
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          WORKER_IPS=$(cat terraform_output.txt | grep "WORKER_IPS" | cut -d'=' -f2)
          MASTER_PRIVATE_IP=$(cat terraform_output.txt | grep "MASTER_PRIVATE_IP" | cut -d'=' -f2)
          WORKER_PRIVATE_IP=$(cat terraform_output.txt | grep "WORKER_PRIVATE_IP" | cut -d'=' -f2)
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@${MASTER_IPS} << 'EOF'
            /usr/local/bin/k3s kubectl get nodes
          EOF

      - name: Install Helm on Master Node
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$MASTER_IPS << 'EOF'
            curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
            chmod 700 get_helm.sh
            sh get_helm.sh 
          EOF

      - name: Clone the Repository on Master Node
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$MASTER_IPS << 'EOF'
            git clone https://github.com/ma914372/devops-coding-challenge.git
          EOF

      - name: Deploy Helm Chart on K3s
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$MASTER_IPS << 'EOF'
            cd devops-coding-challenge
            kubectl create ns app
            kubectl label namespace app app.kubernetes.io/managed-by=Helm 
            kubectl annotate namespace app meta.helm.sh/release-name=app 
            kubectl annotate namespace app meta.helm.sh/release-namespace=app
            helm repo add bitnami https://charts.bitnami.com/bitnami
            helm repo update
            helm dependency update ./app --namespace app
            helm install app ./app --namespace app
          EOF

      - name: Verify Application Deployment
        run: |
          MASTER_IPS=$(cat terraform_output.txt | grep "MASTER_IPS" | cut -d'=' -f2)
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$MASTER_IPS << 'EOF'
            kubectl get pods -A
          EOF   
